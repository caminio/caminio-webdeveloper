{
  "name": "carver",
  "version": "0.1.3",
  "description": "static site generator",
  "main": "index.js",
  "scripts": {
    "test": "grunt test"
  },
  "bin": {
    "carver": "bin/carver.js"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:caminio/carver.git"
  },
  "keywords": [
    "static",
    "site",
    "generator",
    "web",
    "site",
    "generator"
  ],
  "author": {
    "name": "thorsten zerha",
    "email": "quaqua@tastenwerk.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/caminio/carver/issues"
  },
  "homepage": "https://github.com/caminio/carver",
  "devDependencies": {
    "grunt": "~0.4.5",
    "grunt-mocha-test": "~0.10.2",
    "chai": "~1.9.1",
    "grunt-contrib-clean": "~0.5.0",
    "grunt-contrib-yuidoc": "~0.5.2",
    "chai-as-promised": "~4.1.1",
    "chai-fs": "0.0.3"
  },
  "dependencies": {
    "lodash": "~2.4.1",
    "marked": "~0.3.2",
    "mkdirp": "~0.5.0",
    "winston": "~0.7.3",
    "jade": "~1.3.1",
    "rsvp": "~3.0.7",
    "commander": "~2.2.0",
    "colors": "~0.6.2",
    "inflection": "~1.3.6",
    "async": "^0.9.0"
  },
  "readme": "[![Build Status](https://travis-ci.org/caminio/carver.png)](https://travis-ci.org/caminio/sitter)\n\n# Features\n\ncarver is a static site generator with loads of features.\n\nWe know, there are loads of static site generators out there in the node world. But for our \nuse case we needed something highly modularizable and adaptable. this static site generator\ncan:\n\n* render plain content files with additional use of middleware processors (such as our pebbles concept)\n* render (db-)objects with a customizable property (here: 'content')\n* render (db-)objects iterating through an array of objects containing the content attribute (here: 'translations')\n* plug in any engine that returns something (jade, swig, ejs, you name em)\n* plug in any writer defining the destination where the result should go to (works without writer as callback result)\n* ... many more\n\n    \n    var carver = require('carver');\n\nSimple example rendering markdown content\n\n    carver()\n      .includeMarkdownEngine()\n      .render( '# Heading\\nFloating text' )\n      .then( function( html ){\n        // do something with the html\n      });\n\nAdvanced example parsing the given cwd (working directory) for templatefiles and executes\nthem. Default is ``index.<engine>``, here ``index.jade``. To change this, use ``.set('template','mytemplate')``.\n\n    carver()\n      .includeFileWriter()\n      .registerEngine('jade', require('jade'))\n      .set('cwd', __dirname+'/layouts')\n      .write()\n      .then( function( compiler ){\n        console.log('Your webpage has been written to', compiler.finalFilename);\n      });\n\nEven more advanced example with a ``before.render``-hook enabled, precompiling markdown content\nof given ``doc`` object. If ``doc.content`` is available, it will interpreted as markdown and the\nresult will be provided as ``markdownContent`` to the template.<engine>.\n\n    carver()\n      .includeFileWriter()\n      .registerEngine('jade', require('jade'))\n      .set('cwd', __dirname+'/layouts')\n      .set('doc', webpage)\n      .registerHook('before.render', require('carver/plugins').markdownCompiler)\n      .write()\n      .then( function( compiler ){\n        console.log('Your webpage has been written to', compiler.finalFilename);\n      });\n\n# Examples\n\nFor a working example and to clarify a lot of things, it might be useful to have a look at\n\nhttps://github.com/caminio/carver-example.git\n\n\n# Installation\n\n    npm install carver\n\n# Introduction\n\ncarver is chainable. You just add settings and methods one after other (as demonstrated in the example above).\n\ncarver provides 2 different mechanism of rendering:\n\n* low-level with ``.render('any string')`` returning the rendered string\n* high-level through ``.write()`` which requires a ``set('cwd','/path/to/my/cwd')`` to be set and makes use of templates and settings found there. Read more about the workdir (cwd) in the [section below](#workdir)\n\n## Engines\n\nAn engine is responsible for compiling the given content into whatever (usually html). By default, no engine is\navailable and carver would just pass back the same content as entered.\n\n### Register an engine\n\n    carver()\n      .registerEngine('ejs', require('ejs'));\n\nAs you can see, you simple require the official ``ejs`` module and it's native ``.render`` method will work. You can\ndo this with any module supporting that express like behavior.\n\n## Writers\n\nA writer is - compared to an engine - a little bit more work of customization.\n1. It will only be applied if a cwd (a working directory containing template files) has been set (it will read it's config/env.js file and use it as it's working directory)\n2. It is registered with a protocol name, so in the config/env.js a 'destination' property can be set telling carver where to store the file\n\nIf the config/env.js looks like this:\n\n    ...\n    destination: 'file:///my/path/to/public'\n    ...\n\ncarver looks up in it's writers registry for a ``file`` handler and triggers that one when ``write()`` is called.\n\n\n### Register a writer\n\n    carver()\n      .registerWriter('webdav', myWebdavWriter);\n\nLuckily, carver provides the most common writer, the filesystem writer. Enable it with:\n\n    carver()\n      .includeFileWriter();\n\n\n### changing the filename according to runtime options\n\nYou can change your final filename within a before hook by setting ``options.filename`` to whatever is required. The final absolute path is computed by considering ``options.destinations`` as well as ``options.filename``.\n\nYou can request a copy of the current computed file to be stored under a different filename. This is quite handy, if you are rendering calendar programmes where the current month is listed as the index.htm or somewhere different wheras the ordinary programme files are located under ``/programme/02-2014``. This can be achieved with the\n\n### ``options.copyFilenames`` - Array\n\nThis options allows you to save copies of the current render result. just fill options.copyFilenames with relative paths (relative to the destinations directories).\n\n    compiler.options.copyFilenames = ['index'];\n\n\n\n##<a name='hooks'></a> Hooks\n\nHooks plug in at different stages of the compile process, execute a code and resolve to the next hook.\nCurrently the following hooks are available in the following order\n\n* before.render\n* after.render\n* before.write (only in case of cwd)\n* after.write\n\nExample:\n\n    carver()\n      .registerHook('before.render', function( compiler, resolve){ \n        // do something and e.g.: \n        compiler.options.locals.myVar = 123;\n        resolve();\n      });\n\n\n##<a name=\"workdir\"></a> Working with cwd (working directories)\n\nThe default use-case probably is, that you will work with objects somehow created (db?), passed on to carver along with a \nworking directory and letting carver do the rest:\n\n* resolve the cwd and process it's file system structure\n  * load all <template>.hooks.js and <template>.<engine>\n  * register their hooks\n* check the passed in object for translations (manyKey) and recursively instantiate a compiler for each translation\n\nSo basically, the workdir can be understood as a mini-(M)VC framework structure, whereas the model comes from some different\nsource.\n\n### controllers (.hooks.js)\n\nA controller (hook) file can be plugged in at different stages of the rendering process. See the [hooks](#hooks) section above\nfor available hooks.\n\nA typical .hooks.js file looks like this:\n\n    module.exports = {\n\n      'before.render': function( content, compiler, resolve ){\n        content = content.toLowerCase();\n        resolve(content);\n      }\n      \n    };\n\nA hook function is internally wrapped with an RSVP promise. That's why we call the callback ``resolve``. Whereas we are treating\nthese files as hooks, that are just manipulating the content, it is also possible, to create the actual content in a hook. Carver\naccepts ``.render()`` without an argument - as well as ``.writer()``.\n\n#### ``.setup``\n\n    module.exports.setup = function( compiler ){\n      // do some stuff with compiler, e.g. if different situations for different template files\n      // termine them and:\n      compiler.registerEngine('html', myPureHTMLEngine);\n      compiler.useEngine('html');\n    }\n\nJust be aware, there is no promise awareness within the setup yet.\n\n### config/env.js\n\nEvery workdir should contain a configuration file called ``env.js`` within a ``config`` directory. This is done automatically\nby the [carver commandlin helper](#commandlinehelper).\n\n## Working with objects\n\nAlso a common use-case is to not pass the text content but objects with fields containing these contents. That simplifies\nthe syntax, as you might want the object to be available for further processing within carver.\n\n### set('doc')\n\n  With ``.set('doc', obj )``, \n\n##<a name='commandlinehelper'></a> carver commandline helper\n\nTo simplify the process of creating a workdir, carver comes with a commandline tool that can do this job for you.\n\n    carver new <workdir-name>\n\nsets up a basic configuration containing the ``config/env.js`` and an example index.jade and index.hooks.js file. If you prefer a\nplain directory, use the ``--plain`` flag.\n\n## internationalization\n\nCausing carver to create a structure like:\n\n    <filename>.htm.en\n    <filename>.htm.de\n\nIf your object has, let's say a ``translations`` array housing objects which look similar to the root object but store translated\nversions of the original object (we only use translations in [caminio](http://caminio.github.com), even if there is no need for translations).\n\nIf translations are found, the render/write process is triggered for each translation file, with the ``@options.lang`` flag set according\nto the current translation. The actual content would be the same, if you don't traverse internally to the right translation. This can be \ndone with a ``before.render``-hook and reading out the ``compiler.options.lang`` property, which is available for pre/postprocessor hooks.\n\n## publishing mechanism\n\ncarver comes with a simple publishing mechanism. Every written content will be written to the ``drafts``-directory (defined in the \nconfig/env.js or directly through set('drafts', ...)).\n\nNow, if you are using a publish-status key, let's say in your documents's ``status`` property, carver recognizes the flag as documented below:\n\n### ``published``\n\ncarver renders everything set up. This includes ``drafts`` plus all ``destinations``.\n\n### ``draft``\n\ncarver only runs the drafts section, skipping the rest.\n\n## dependencies\n\nIf you compile a webpage, it happens quite regularily, that the webpage is refered to from another webpage. E.g. if the title of the webpage\nchanges, it is neccessary to re-render all the webpages who refer to the current webpage. Also, thinking of any kind of navigation. carver\ndoesn't help you with finding those dependencies, but it lets you define an array of dependending objects along with a workdir (cwd) option.\n\n    carver()\n      .set('doc', obj )\n      .dependencies({ doc: obj1, cwd: '/path/to/workdir/of/obj1' });\n\nBasically, this options are the same options, you can set with the ``.set()`` method. All other settings will be inherited from the current\ncarver instance settings to a new carver instance, which in turn can have dependencies again, if defined in the workdir's dependencies property.\n\nIf used in the workdir, it might be useful to be able to add a doc object by a promise:\n\n    ...\n    dependencies: [\n      { \n        doc: function( compiler, resolve, reject ){ \n                compiler.set('doc', getMyDoc());\n                resolve();\n              });\n      }\n    ]\n\n## config/env.js\n\nThere is no global settings file carver is interested in. It always just looks out for the ``config/env.js`` within the current\nworking directory. This is very important to note.\n\n### destinations\n\nAn array of strings defining destinations to write to with the writer.\n\nExample:\n\n    destinations: [ 'file:///absolute/path/to/my/public' ]\n\nThis would write the resulted file (name is taken either from the @options.filename, doc[@options.filenameKey] or @options.template) to the absolute directory on the filesystem. A writer needs to have been registered before initiating the ``.write`` method (e.g.: ``includeFileWriter()``).\n\nThe protocol part is taken to look up for the writer. Here, a writer with the name ``file`` needs to be registered. It is also possible to register your own writers copying content to ftp, ssh or something similar. The writer just gets ``content``, the content, ``filename`` the destination part (sliced from the protocol part), ``compiler``, the current carver instance and ``resolve``, the promise resolver.\n\n### dependencies\n\nAn array of option objects containing information for any dependencies to be run after this workdir render/write process has finished.\n\nExample:\n\n    dependencies: [ { cwd: '/other/cwd/path', docArrayKey: 'siblings' } ]\n\nsepcial options are:\n\n* ``docArrayKey`` - iterates over the array instantiating a new carver for each document. The ``docArrayKey`` has to be present in the ``@options.locals`` object.\n* ``docKey`` - calls a new carver instance with the ``docKey`` (must be present in ``@options.locals``).\n\n### drafts\n\nA string (in the same format of ``destinations``) where draft pages should be stored. This only takes effect, if the option ``publishingStatusKey`` is set (default: 'status'). Read more about it in the [publishing mechanisms](#publishing) section.\n",
  "readmeFilename": "README.md",
  "_id": "carver@0.1.3",
  "dist": {
    "shasum": "db3b705af380c21d26369990f5f889dcad9acf9b"
  },
  "_resolved": "git://github.com/caminio/carver.git#1c3d1e6b619f583738b02feed146d1b01a4bc479",
  "_from": "carver@git://github.com/caminio/carver.git#master"
}
