{
  "name": "carver",
  "version": "0.0.4",
  "description": "static site generator",
  "main": "index.js",
  "scripts": {
    "test": "grunt test"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:caminio/carver.git"
  },
  "keywords": [
    "static",
    "site",
    "generator",
    "web",
    "site",
    "generator"
  ],
  "author": {
    "name": "thorsten zerha",
    "email": "quaqua@tastenwerk.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/caminio/carver/issues"
  },
  "homepage": "https://github.com/caminio/carver",
  "devDependencies": {
    "grunt": "~0.4.5",
    "grunt-mocha-test": "~0.10.2",
    "chai": "~1.9.1",
    "grunt-contrib-clean": "~0.5.0",
    "grunt-contrib-yuidoc": "~0.5.2"
  },
  "dependencies": {
    "marked": "~0.3.2",
    "lodash": "~2.4.1",
    "mkdirp": "~0.5.0",
    "jade": "~1.3.1",
    "winston": "~0.7.3",
    "async": "~0.9.0"
  },
  "readme": "[![Build Status](https://travis-ci.org/caminio/sitter.png)](https://travis-ci.org/caminio/sitter)\n\n# sitter\n\nsitter is a static html page generator. It has a modularized core where all kinds of compilers\ncan be added.\n\n## Installation\n\n    npm install sitter\n\n## Overview\n\n    var Sitter = require('sitter');\n    var compiler = Sitter.init({ workdir: '/my/workdir' });\n\n    // define templates with your favorite template engine\n    // like .jade, .swig, .ejs, .handlebars, ...\n    // fetch webpages or whatever from your database\n\n    webpages.forEach(function(webpage){\n      compiler.compile( webpage );\n    });\n\n## Introduction\n\nThe most common use of sitter is through a workdir. The **workdir** defines the root of your static\ncontent. But not necessarily the root of your web site. A typical sitter structure looks like this:\n\n    workdir\n      /public                 // your public directory declared in your web server's config\n      /templates              // name this whatever you want. But ``templates`` suits nice. This\n                              // path needs to be declared as an option to the Sitter compile method\n\n### initializing Sitter\n\n    var Sitter = require('sitter');\n    var compiler = Sitter.init({ workdir: '/my/work/dir/templates' });\n\nNow you can compile all different kinds of objects or strings. \"Objects\", you may ask? Yes. For more see\n the next heading. First we just compile some simple text.\n\n    compiler.compile( '# Heading\\nNormal Text', { engine: 'markdown' } );\n\nThis returns the html result of the markdown compiler. We are using [marked](https://github.com/chjj/marked),\nwhich we found is a very robust and flexible compiler with github pages support. But that's actually not what\nwe're after. We want it to be stored in a file:\n\n    compiler.compile();\n\nThis will run through the workdir checking for a template called ``index`` (or if you passed in a ``template`` option\nfor the name given) and search for a valid engine extension:\n\n    workdir\n      /templates\n        /index.jade\n\nPerfect match! Jade support is built-in. Of course, you can snap in any engine you want. It's really simple. See below\nfor more details. If nothing else was passed into the compile method, that'll do it. An index.htm file will be generated\nto the specified ``destination`` folder (defined in workdir/.settings.js).\n\n### compiling objects\n\nThe fun begins with objects. Let's asume, you have objects like this:\n\n    mywebpage = { (...any attributes...), content: '#my content in markdown' };\n\nNow, just pass this object into the compiler:\n\n    compiler.compile( webpage );\n\nThis will pass a ``content`` attribute to the locals object before compiling the template of your workdir.\nIt will have the same effect as if you would do:\n\n    compiler.compile( null, { locals: { content: compiler.compile(webpage.content) } } );\n\n#### templates\n\nBut you would want to define different kinds of layouts / templates for your webpage. For example, the index,\ndefault, a gallery, the blog and so on.\n\n    compiler.compile( webpage, { template: 'default' });\n\nThis looks up a template in your workdir named 'default/' and requires an engin - valid file with the same name\ninside. Here: 'default.jade'. Oh, and, of course, you can have your webpage store that template as well.\n\nIf the given object has a ``template`` property, that will used instead.\n\n#### filename\n\nAs we don't want our webpages to override each other, we want to specify a name for the location.\n\n    compiler.compile( webpage, { filename: 'myfile' })\n\nAnd this of course would be unneccessary type stuff. Of course, as with the template, the filename property of\nthe webpage will be taken into account instead. So basically, if you have an object containing\n\n* content\n* filename\n* layout or template\n\nYou don't need to pass any options along with the compile method.\n\n#### hirarchy\n\nIt doesn't occur seldomly, that webpages are nested. This nesting needs to be mirrored somehow in the final\nstructure of the static website.\n\nApparently that's a database task. But, if you add a ``ancestors`` - array to your webpage, sitter will try to read in\ntheir ``filename`` attributes sticking them all together to build a full path to your webpage.\n\n### i18n - multi language support\n\nIf you webpage or whatever object has a ``translations`` array with the following structure, it will be parsed and a\n.html.[lang] file will be created for each translation.\n\n* content\n* locale\n\n### Options for ``.settings.js``\n\n#### destination\n\n##### relative path\n\n    '../public/my/path'\n\nA path relative to the workdir\n\n##### file:///\n\n    'file:///srv/my/path'\n\nAn absolute path somewhere in the filesystem. Non existent directories will be created\n\n\n##### ftp://\n\n    'ftp://<user>:<pass>@<host>'\n\nThis feature is not implemented yet\n\n## Extending sitter\n\n### engine\n\nAn engine just needs to export a ``.compile`` method. The plaintext compiler as a skeleton\nlooks like this:\n\n    module.exports.compile = function( content, options, callback ){\n      \n      if( typeof(callback) === 'function' )\n        return callback( null, content );\n\n      return content;\n\n    }\n\n    Sitter.registerEngine( 'text', require('content-above-in-a-file') );\n\n### writer\n\nA writer is responsible for writing the resulting content somehwere. The only native writer is\nthe file writer (currently).\n\n\n    module.exports = function fileWriter( content, filename, options, callback ){\n\n      // do something in here\n\n      callback();\n\n    }\n\n\n",
  "readmeFilename": "README.md",
  "_id": "carver@0.0.4",
  "_from": "carver@~0.0.4"
}
